
/*
 *
 */

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <forward_list>

using namespace std;

#define error(a, ...) \
    fprintf(stderr, "\033[0;33m" a "\033[0;37m\n", ##__VA_ARGS__)

#define MAXLEN 40       // maximale Wortlänge
#define CHRCNT (26 + 5) // = lowercase + äöüß + 1 for others

// speichert Wörter sortiert nach Länge
forward_list<char*> wordMap[MAXLEN][CHRCNT];

bool tryOpen(const char* name, FILE*& fp) {
    fp = fopen(name, "r");
    if (fp == NULL) {
        error("Error opening '%s'", name);
        return true;
    }
    return false;
}

uint8_t charNum(char* cp) {
    static char lc;

    if (*cp >= 'A' && *cp <= 'Z') return *cp - 'A';
    if (*cp >= 'a' && *cp <= 'z') return *cp - 'a';

    uint8_t sub = 0;           //  Ergebnis-Subtrahent
    bool isSpec = *cp == *"ü"; // Status: ist Umlaut

    // Umlaute sind nicht in ASCII enthalten, stattdessen bestehen sie aus zwei
    // ASCII-Zeichen, wobei der erste (hier) bei alles gleich ist
    if (isSpec || lc == *"ü") {
        lc = *cp;

        // vergleiche nächstes Zeichen wenn das letzte ein Umlautbeginn war,
        // sonst das erste
        switch (cp[isSpec]) {
            case "ü"[1]:
            case "Ü"[1]: sub = 2; break;
            case "ä"[1]:
            case "Ä"[1]: sub = 3; break;
            case "ö"[1]:
            case "Ö"[1]: sub = 4; break;
            case "ß"[1]: sub = 5; break;
            default: sub = 0;
        }

        if (sub && isSpec) sub = 1;
    }
    return CHRCNT - sub;
}

uint16_t cntUml(char* word, uint16_t len = -1) {
    char* c    = word;
    uint16_t n = 0, i;

    if (len == -1) {
        while (*c)
            if (*c++ == *"ü") n++;
    } else {
        for (i = 0; i < len && *c; i++)
            if (*c++ == *"ü") n++;
    }

    return n;
}

void freeWordMap() {
    uint8_t i, j;
    for (i = 0; i < MAXLEN; i++) {
        for (j = 0; j < CHRCNT; j++) {
            wordMap[i][j].remove_if([](char* word) {
                free(word);
                return true;
            });
        }
    }
}

bool initWordMap() {
    FILE* fp;
    char* line = NULL;
    ssize_t read;
    size_t len = 0;

    if (tryOpen("res/woerterliste.txt", fp)) return true;
    while ((read = getline(&line, &len, fp)) != -1) {
        if (read > 1) {
            if (line[read - 1] == '\n') read--;
            if (read > MAXLEN) error("word %.*s too long", (int)read, line);
            wordMap[read - cntUml(line, read)][charNum(line)].push_front(
                strndup(line, read));
        }
    }
    fclose(fp);
    return false;
}

int main(int argc, const char* argv[]) {
    if (initWordMap()) return 1;
    FILE* fp   = NULL;
    char* line = NULL;
    ssize_t read;
    size_t len = 0;

    if (argc > 1) tryOpen(argv[1], fp);

    if (fp == NULL && tryOpen("res/enttwist.txt", fp)) {
        error("initialization failed");
        fclose(fp);
        freeWordMap();
        return 1;
    }

    /* gibt Anzahl der Wörter einer Wortlänge aus
    printf(
        "    a    b    c    d    e    f    g    h    i    j    k    "
        "l    m    n    o    p    q    r    s    t    u    v    w   "
        "  x     y     z\n");
    for (len = 0; len < MAXLEN; len++) {
        for (read = 0; read < CHRCNT; read++)
            printf(
                "%5li",
                distance(wordMap[len][read].begin(), wordMap[len][read].end()));
        printf("\n");
    }
    printf("\n");*/

    // lese Eingabedatei zeilenweise
    while ((read = getline(&line, &len, fp)) != -1) {
        if (read > 1) {
            char *c = line, *b;
            uint16_t l;

            do {
                // lese nicht-Wörter
                l = 0;
                b = c;
                while (*c && charNum(c) == CHRCNT) c++, l++;
                printf("%.*s", l, b);

                // lese Wörter
                l = 0;
                b = c;
                while (*c && charNum(c) != CHRCNT) c++, l++;

                // Keine vertauschten Bst. möglich
                if (l < 3 || l - cntUml(b, l) <= 3) {
                    printf("\033[0;32m%.*s\033[0;37m", l, b);
                    continue;

                    // Wort zu lang
                } else if (l > MAXLEN) {
                    printf("\033[0;31m%.*s\033[0;37m", l, b);
                    continue;
                }

                char p[l], *match = NULL;
                uint8_t i, j, found = 0;

                // suche Basiswörter
                for (char* word: wordMap[l - cntUml(b, l)][charNum(b)]) {
                    if ((b[l - 1] != word[l - 1]) || // Endbst. verschieden
                        ((b[0] != word[0]) &&        // Anfangsbst. verschieden
                         (b[0] != word[0] - 'a' + 'A')) // klein->groß
                    )
                        continue;

                    // kopiere Eingabewort zu p für Buchstabenzählung
                    strncpy(p, b, l);

                    // von 1 - l-1 weil Anfangs- und Endbuchstaben bereits
                    // überprüft worden sind
                    for (i = 1; i < l - 1; i++) {
                        for (j = 1; j < l - 1; j++) {
                            if (charNum(word + i) == charNum(p + j)) {
                                p[j] = ' '; // überschreibe gefundene Zeichen
                                break;
                            }
                        }

                        // Zeichen nicht gefunden
                        if (j == l - 1) break;
                    }

                    // alle Zeichen gefunden
                    if (i == l - 1) {
                        if (match) {
                            // gleiches Wort gefunden -> überspringen
                            if (!strncmp(match + 1, word + 1, l - 1)) continue;

                            // bereits anderes Wort gefunden -> gelb
                            printf("\033[0;33m%.*s\033[0;37m|", l, match);
                        }

                        // kopiere richtiges Wort temporär in Eingabezeile
                        // Anfangs- und Endbuchstabe wird beibehalten
                        strncpy(b + 1, word + 1, l - 2);
                        match = b;
                        found++;
                    }
                }

                if (found == 1) // eine Übereinstimmung -> grün
                    printf("\033[0;32m%.*s\033[0;37m", l, match);
                else if (!found) // keine Übereinstimmung -> rot
                    printf("\033[0;31m%.*s\033[0;37m", l, b);
                else // mehrere Übereinstimmungen -> gelb
                    printf("\033[0;33m%.*s\033[0;37m", l, match);

            } while (*c);
        } else
            printf("\n");
    }

    printf("\n");
    fclose(fp);
    free(line);
    freeWordMap();
    return 0;
}
