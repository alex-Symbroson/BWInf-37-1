
/*
 *
 */

#include "headers.hpp"

using namespace std;

#define error(a, ...) \
    fprintf(stderr, "\033[0;33m" a "\033[0;37m\n", ##__VA_ARGS__)

#define MAXLEN 40
#define CHRCNT (26 + 5) // = lowercase + äöüß + 1 for others

// (Zeiger auf Wortanfang) Liste[Wortlänge]
forward_list<wchar_t*> wordMap[MAXLEN];

bool tryOpen(const char* name, FILE*& fp) {
    fp = fopen(name, "r");
    if (fp == NULL) {
        error("Error opening '%s'", name);
        return true;
    }
    return false;
}

uint8_t charNum(wchar_t c) {
    if (c >= L'A' && c <= L'Z') return c - L'A';
    if (c >= L'a' && c <= L'z') return c - L'a';

    // Sonderzeichen sind nicht in ASCII enthalten, stattdessen
    // bestehen sie aus zwei ASCII-Zeichen, wobei der erste bei
    // alles gleich ist
    switch (c) {
        case L'ü':
        case L'Ü': return CHRCNT - 2;
        case L'ä':
        case L'Ä': return CHRCNT - 3;
        case L'ö':
        case L'Ö': return CHRCNT - 4;
        case L'ß': return CHRCNT - 5;
    }

    return CHRCNT;
}

void freeWordMap() {
    uint8_t i;
    for (i = 0; i < MAXLEN; i++) {
        wordMap[i].remove_if([](wchar_t* word) {
            delete word;
            return true;
        });
    }
}

bool initWordMap() {
    FILE* fp;
    char* line = NULL;
    ssize_t read;
    size_t len = 0;

    if (tryOpen("res/woerterliste2.txt", fp)) return true;
    while ((read = getline(&line, &len, fp)) != -1) {
        if (--read > 1) {
            if (read > MAXLEN) error("word %.*s too long", (int)read, line);
            wchar_t* wline = new wchar_t[read + 1];
            mbstowcs(wline, line, read + 1);
            wordMap[read].push_front(wline);
        }
    }
    fclose(fp);
    return false;
}

int main(int argc, const char* argv[]) {
    if (initWordMap()) return 1;
    FILE* fp   = NULL;
    char* line = NULL;
    ssize_t read;
    size_t len = 0;

    if (argc > 1) tryOpen(argv[1], fp);

    if (fp == NULL && tryOpen("res/enttwist.txt", fp)) {
        error("initialization failed");
        fclose(fp);
        freeWordMap();
        return 1;
    }

    // lese Eingabedatei zeilenweise
    while ((read = getline(&line, &len, fp)) != -1) {
        if (read > 1) {
            wchar_t *wline, *b, *c;
            uint8_t l, len = 0;

            wline = new wchar_t[read + 1];
            mbstowcs(wline, line, read);
            c = wline;
            // printf("1\n");
            // printf("%lu %.*S\n", read, (int)read, c);
            // printf("2\n");

            do {
                // lese nicht-Wörter
                l = 0, b = c;
                while (len < read && (charNum(*c) == CHRCNT)) c++, l++, len++;
                printf("%.*S", l, b);

                // lese Wörter
                l = 0, b = c;
                while (len < read && charNum(*c) != CHRCNT) c++, l++, len++;
                if (len >= read) break;

                // Wort muss stimmen
                /*if (l <= 3) {
                    printf("\033[0;32m%.*s\033[0;37m", l, b);
                    continue;
                }*/

                wchar_t p[l];
                uint8_t i, j, found = 0;
                forward_list<wchar_t*> matches;
                // suche Basiswörter
                for (wchar_t* word: wordMap[l]) {
                    // die Anfangs- und Endbuchstaben müssen übereinstimmen
                    // und groß geschriebene Eingabewörter können in der
                    // Wortliste kleingeschrieben sein, aber nicht umgekehrt
                    if ((b[l - 1] != word[l - 1]) ||
                        ((b[0] != word[0]) && (b[0] != word[0] - L'a' + L'A')))
                        continue;

                    wcsncpy(p, b, l);

                    // von 1 - l-1 weil Anfangs- und Endbuchstaben bereits
                    // überprüft worden sind
                    for (i = 1; i < l - 1; i++) {
                        for (j = 1; j < l - 1; j++) {
                            if (charNum(word[i]) == charNum(p[j])) {
                                p[j] = L'-'; // überschreibe gefundene Zeichen
                                break;
                            }
                        }

                        // Zeichen nicht gefunden
                        if (j == l - 1) break;
                    }

                    // alle Zeichen gefunden
                    if (i == l - 1) {
                        wcsncpy(b + 1, word + 1, l - 1);
                        matches.push_front(b);
                        found++;
                    }
                }

                switch (found) {
                    case 1: // eindeutig
                        printf("\033[0;32m%.*S\033[0;37m", l, matches.front());
                        break;

                    case 0: // keine Übereinstimmung
                        printf("\033[0;31m%.*S\033[0;37m", l, b);
                        break;

                    default: // mehrdeutig
                        for (wchar_t* word: matches) {
                            printf("\033[0;33m%.*S\033[0;37m", l, word);
                            if (--found) printf("|");
                        }
                }
            } while (len < read);
            delete wline;
        }
    }

    printf("\n");
    free(line);
    fclose(fp);
    freeWordMap();
    return 0;
}
